# 细节思考

开发过程中，遇到什么问题或想到什么，记录在这里

## 指纹设计

* SHA256, 保密性强，长度足够，hash冲突的概率，但是计算较慢，

* **Go 语言** ：使用标准库 `crypto/sha256`。它在 Go 1.20 之后，对于支持 SHA 扩展指令集的 CPU 自动使用了硬件加速，无需任何额外配置。
* 后续可尝试其它hash算法

### SHA-256 哈希冲突的理论概率

SHA-256 算法生成的哈希值是**256位**长，这意味着它可能的哈希值数量是 **2的**256次方。

**2的**256次方 是一个天文数字，可以写成 **115**,**792**,**089**,**237**,**316**,**195**,**423**,**570**,**985**,**008**,**687**,**907**,**853**,**269**,**984**,**665**,**640**,**564**,**039**,**457**,**584**,**007**,**913**,**129**,**639**,**936**

可以把这个数字想象成一个巨大的“哈希桶”，每个桶里可以装一个哈希值。由于桶的数量如此之多，随机地放入两个不同的输入，它们最终落入同一个桶的概率微乎其微。

这远远小于磁盘位丢失的概率：谷歌的一项研究发现，在他们庞大的数据中心里，大约 **每 15 个月，每 1 PB（1000 TB）的数据** 就会发生一次静默的位丢失。这只是一个平均值，具体到某个硬盘，这个概率可能高很多，也可能几十年都不发生一次。

## 指纹存储

目前存储和拷贝分别使用了redis的string和go的string， 经考证，它们都是二进制安全的，也就是说不存在遇到0终止的问题（这和C/C++的字符串有很大的不同），因此目前没有打算对存储格式做序列化和反序列化。序列化后的指纹占用空间会增加不少

* 一个指纹占32字节的空间
* 目前hash cache是利用redis的hash table做的，partition是根据去重命名空间做的隔离。在查找性能上需要做些专门的压力测试才能看看是否需要额外的优化

* 后续考虑引入Sparse Indexing来针对指纹集占用的内存空间做优化
* 查询锁的问题，需要仔细研究一下，是否可以通过减小锁的粒度来提高并发查询的性能

## 命名空间

这里难点在于S3的协议都是公共标准的，用户应该通过什么方使传入这个自定义的命名空间呢，如何记录哪个桶属于哪个命名空间呢

* bucket名字带有namespace信息，以'.'位分隔符，'.'前面的部分位namespace， 整体做为bucket name，这样Xlator会将namespace一样的归入一个指纹集合
* 对bucket名字加入额外的错误检测，除原本要求外，还要求必须检测到namespace

## 集群的发现

* 选主：
* 主统计所有从的信息
* 集群的负载，节点的选择

## 安全

* 链路安全：TLS
* 各个模块的登录认证安全：redis/MinIO/Xlator...？
* 数据安全：object lock/versionning?

## 高可用

* 数据的高可用：依赖于各模块的集群服务：redis的持久化、哨兵/MinIO的EC...
* 服务的高可用：docker/k8s?
* 集群间的数据拷贝（Replication）
